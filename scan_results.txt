bssid / frequency / signal level / flags / ssid
18:45:93:67:ef:ad	5240	-63	[WPA-PSK-CCMP+TKIP][WPA2-PSK-CCMP+TKIP][ESS]	Airtel_9850990060
1a:45:93:17:ef:ad	5240	-65	[WPA-PSK-CCMP+TKIP][WPA2-PSK-CCMP+TKIP][ESS]	Airtel_9850990060_5GHz
1a:45:93:47:ef:ad	5240	-65	[WPA2-PSK-CCMP][ESS]	
bc:0f:9a:17:c1:3c	2412	-56	[WPA2-PSK-CCMP][ESS]	NeerajAP
18:45:93:67:ef:a9	2462	-54	[WPA-PSK-CCMP+TKIP][WPA2-PSK-CCMP+TKIP][ESS]	Airtel_9850990060
1a:45:93:17:ef:a9	2462	-60	[WPA-PSK-CCMP+TKIP][WPA2-PSK-CCMP+TKIP][ESS]	Airtel_9850990060_5GHz
5c:8c:30:fd:3d:19	2462	-65	[WPA-PSK-CCMP+TKIP][WPA2-PSK-CCMP+TKIP][ESS]	Airtel_eesh_7915
26:0b:88:4a:53:b9	2437	-68	[WPA2-PSK-CCMP][ESS]	
26:0b:88:1a:53:b9	2437	-69	[WPA-PSK-CCMP+TKIP][WPA2-PSK-CCMP+TKIP][ESS]	Airtel_9921712787_5GHz
24:0b:88:1a:53:b9	2437	-69	[WPA-PSK-CCMP+TKIP][WPA2-PSK-CCMP+TKIP][ESS]	Airtel_9921712787
30:bd:13:2c:1c:36	2437	-82	[WPA-PSK-CCMP+TKIP][WPA2-PSK-CCMP+TKIP][ESS]	Airtel_maya_1111


#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

using namespace std;

struct MobileUser {
    long long mobileNo;
    string name;
    float billAmount;
};

int linearSearch(vector<MobileUser>& users, long long key) {
    for (int i = 0; i < users.size(); i++) {
        if (users[i].mobileNo == key) {
            return i;
        }
    }
    return -1;
}

int binarySearchIterative(vector<MobileUser>& users, long long key) {
    int low = 0;
    int high = users.size() - 1;

    while (low <= high) {
        int mid = low + (high - low) / 2;

        if (users[mid].mobileNo == key)
            return mid;
        
        if (users[mid].mobileNo < key)
            low = mid + 1;
        else
            high = mid - 1;
    }
    return -1;
}

int binarySearchRecursive(vector<MobileUser>& users, int low, int high, long long key) {
    if (low <= high) {
        int mid = low + (high - low) / 2;

        if (users[mid].mobileNo == key)
            return mid;
        
        if (users[mid].mobileNo < key)
            return binarySearchRecursive(users, mid + 1, high, key);
        
        return binarySearchRecursive(users, low, mid - 1, key);
    }
    return -1;
}

bool compareUsers(const MobileUser& a, const MobileUser& b) {
    return a.mobileNo < b.mobileNo;
}

void display(MobileUser u) {
    cout << "\nFound Record:\n";
    cout << "Name: " << u.name << "\n";
    cout << "Mobile: " << u.mobileNo << "\n";
    cout << "Bill: " << u.billAmount << "\n";
}

int main() {
    int n, choice, idx = -1;
    long long key;
    
    cout << "Enter number of users: ";
    cin >> n;

    vector<MobileUser> users(n);

    for (int i = 0; i < n; i++) {
        cout << "Enter details for user " << i + 1 << " (Mobile Name Bill): ";
        cin >> users[i].mobileNo >> users[i].name >> users[i].billAmount;
    }

    sort(users.begin(), users.end(), compareUsers);
    
    do {
        cout << "\n1. Linear Search\n2. Binary Search (Iterative)\n3. Binary Search (Recursive)\n4. Exit\nChoice: ";
        cin >> choice;

        if (choice == 4) break;

        cout << "Enter Mobile No to search: ";
        cin >> key;

        switch (choice) {
            case 1:
                idx = linearSearch(users, key);
                break;
            case 2:
                idx = binarySearchIterative(users, key);
                break;
            case 3:
                idx = binarySearchRecursive(users, 0, n - 1, key);
                break;
            default:
                cout << "Invalid choice\n";
                continue;
        }

        if (idx != -1)
            display(users[idx]);
        else
            cout << "Record not found\n";

    } while (choice != 4);

    return 0;
}


